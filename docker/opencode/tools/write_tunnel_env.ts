import { tool } from "@opencode-ai/plugin"
import { writeFile } from "fs/promises"

type TunnelEntry = {
  name: string
  url?: string
  path?: string
  port?: number
  protocol?: string
}

function toEnvKey(prefix: string, name: string) {
  const normalized = name.replace(/[^a-zA-Z0-9]+/g, "_").replace(/^_+|_+$/g, "")
  return `${prefix}${normalized.toUpperCase()}_URL`
}

export default tool({
  description:
    "Fetch the current session's tunnel URLs and write them to an env file for local app configuration.",
  args: {
    file_path: tool.schema
      .string()
      .optional()
      .describe("Path to write env file (default: .env.tunnels)"),
    prefix: tool.schema
      .string()
      .optional()
      .describe("Env var prefix for tunnel URLs (default: TUNNEL_)"),
    token: tool.schema
      .string()
      .optional()
      .describe("Optional JWT token to append to tunnel URLs"),
    token_env: tool.schema
      .string()
      .optional()
      .describe("Env var name to read token from (default: SANDBOX_TOKEN)"),
    include_token: tool.schema
      .boolean()
      .optional()
      .describe("Append token to URLs when available (default: true)"),
    set_api_url_from: tool.schema
      .string()
      .optional()
      .describe("If provided, set API_URL from this tunnel name (default: api)"),
    set_frontend_url_from: tool.schema
      .string()
      .optional()
      .describe("If provided, set FRONTEND_URL from this tunnel name (default: frontend)"),
    set_backend_url_from: tool.schema
      .string()
      .optional()
      .describe("If provided, set BACKEND_URL from this tunnel name (default: backend)"),
    include_gateway: tool.schema
      .boolean()
      .optional()
      .describe("Include GATEWAY_URL from tunnelUrls.gateway if present (default: true)"),
    session_id: tool.schema
      .string()
      .optional()
      .describe("Override session ID (defaults to SESSION_ID env var)"),
  },
  async execute(args) {
    try {
      const sessionId = args.session_id || process.env.SESSION_ID
      if (!sessionId) {
        return "SESSION_ID is not set; pass session_id explicitly."
      }

      const tokenEnvName = args.token_env || "SANDBOX_TOKEN"
      const tokenValue = args.token || process.env[tokenEnvName]
      const shouldAppendToken = args.include_token !== false && !!tokenValue

      const params = new URLSearchParams({ sessionId })
      const res = await fetch(`http://localhost:9000/api/session-status?${params}`)
      if (!res.ok) {
        const errText = await res.text()
        return `Failed to get session status: ${errText}`
      }

      const data = (await res.json()) as { sessionStatus?: unknown }
      const status = data.sessionStatus as {
        tunnelUrls?: Record<string, string> | null
        tunnels?: TunnelEntry[] | null
      } | undefined

      const tunnels = Array.isArray(status?.tunnels) ? status?.tunnels || [] : []
      const prefix = args.prefix ?? "TUNNEL_"
      const lines: string[] = []

      if (args.include_gateway !== false && status?.tunnelUrls?.gateway) {
        lines.push(`GATEWAY_URL=${status.tunnelUrls.gateway}`)
      }

      if (tokenValue) {
        lines.push(`TUNNEL_TOKEN=${tokenValue}`)
      }

      const withToken = (url: string) => {
        if (!shouldAppendToken) return url
        try {
          const parsed = new URL(url)
          parsed.searchParams.set("token", tokenValue as string)
          return parsed.toString()
        } catch {
          const sep = url.includes("?") ? "&" : "?"
          return `${url}${sep}token=${encodeURIComponent(tokenValue as string)}`
        }
      }

      for (const tunnel of tunnels) {
        const url = tunnel.url || (tunnel.path ? `${status?.tunnelUrls?.gateway || ""}${tunnel.path}` : undefined)
        if (!url) continue
        lines.push(`${toEnvKey(prefix, tunnel.name)}=${withToken(url)}`)
      }

      const apiName = args.set_api_url_from ?? "api"
      const frontendName = args.set_frontend_url_from ?? "frontend"
      const backendName = args.set_backend_url_from ?? "backend"

      const findTunnelUrl = (name: string) => {
        const match = tunnels.find((t) => t.name === name)
        return match?.url
      }

      const apiUrl = apiName ? findTunnelUrl(apiName) : undefined
      const frontendUrl = frontendName ? findTunnelUrl(frontendName) : undefined
      const backendUrl = backendName ? findTunnelUrl(backendName) : undefined

      if (apiUrl) lines.push(`API_URL=${withToken(apiUrl)}`)
      if (frontendUrl) lines.push(`FRONTEND_URL=${withToken(frontendUrl)}`)
      if (backendUrl) lines.push(`BACKEND_URL=${withToken(backendUrl)}`)

      const filePath = args.file_path || ".env.tunnels"
      const header = [
        "# Auto-generated by write_tunnel_env",
        `# Session: ${sessionId}`,
        "",
      ]
      await writeFile(filePath, header.concat(lines).join("\n") + "\n", "utf8")

      const summary = lines.length
        ? `Wrote ${lines.length} env var(s) to ${filePath}`
        : `No tunnels found; wrote empty file to ${filePath}`

      return summary
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e)
      return `Failed to write tunnel env: ${msg}`
    }
  },
})
