import { Hono, type Context } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import type { Env, Variables } from '../env.js';
import * as db from '../lib/db.js';
import * as orchestratorService from '../services/orchestrator.js';

// Re-export for backward compatibility (used by index.ts cron handler)
export { restartOrchestratorSession } from '../services/orchestrator.js';

const createIdentityLinkSchema = z.object({
  provider: z.string().min(1).max(50),
  externalId: z.string().min(1).max(255),
  externalName: z.string().max(255).optional(),
  teamId: z.string().max(255).optional(),
});

export const orchestratorRouter = new Hono<{ Bindings: Env; Variables: Variables }>();

// ─── Validation Schemas ──────────────────────────────────────────────────

const createOrchestratorSchema = z.object({
  name: z.string().min(1).max(100),
  handle: z.string().min(1).max(50).regex(/^[a-z0-9_-]+$/, 'Handle must be lowercase alphanumeric with dashes/underscores'),
  avatar: z.string().max(500).optional(),
  customInstructions: z.string().max(10000).optional(),
});

const updateIdentitySchema = z.object({
  name: z.string().min(1).max(100).optional(),
  handle: z.string().min(1).max(50).regex(/^[a-z0-9_-]+$/).optional(),
  avatar: z.string().max(500).optional(),
  customInstructions: z.string().max(10000).optional(),
});

const createMemorySchema = z.object({
  content: z.string().min(1).max(5000),
  category: z.enum(['preference', 'workflow', 'context', 'project', 'decision', 'general']),
});

// ─── Orchestrator Routes ────────────────────────────────────────────────

/**
 * GET /api/me/orchestrator
 * Returns orchestrator info for the current user.
 */
orchestratorRouter.get('/orchestrator', async (c) => {
  const user = c.get('user');

  const info = await orchestratorService.getOrchestratorInfo(c.env.DB, user.id);
  return c.json(info);
});

/**
 * POST /api/me/orchestrator
 * Onboarding: creates identity + session + DO.
 */
orchestratorRouter.post('/orchestrator', zValidator('json', createOrchestratorSchema), async (c) => {
  const user = c.get('user');
  const body = c.req.valid('json');

  const result = await orchestratorService.onboardOrchestrator(
    c.env,
    user.id,
    user.email,
    body,
    c.req.url,
  );

  if (!result.ok) {
    if (result.reason === 'already_exists') {
      return c.json({ error: 'Orchestrator already exists' }, 409);
    }
    if (result.reason === 'handle_taken') {
      return c.json({ error: 'Handle already taken' }, 409);
    }
  }

  if (result.ok) {
    return c.json({ sessionId: result.sessionId, identity: result.identity, session: result.session }, 201);
  }

  // Should not reach here but satisfy TypeScript
  return c.json({ error: 'Unknown error' }, 500);
});

/**
 * GET /api/me/orchestrator/identity
 */
orchestratorRouter.get('/orchestrator/identity', async (c) => {
  const user = c.get('user');
  const identity = await db.getOrchestratorIdentity(c.env.DB, user.id);
  if (!identity) {
    return c.json({ error: 'Orchestrator not set up' }, 404);
  }
  return c.json({ identity });
});

/**
 * PUT /api/me/orchestrator/identity
 */
orchestratorRouter.put('/orchestrator/identity', zValidator('json', updateIdentitySchema), async (c) => {
  const user = c.get('user');
  const body = c.req.valid('json');

  const result = await orchestratorService.updateOrchestratorIdentity(c.env.DB, user.id, body);
  if (!result.ok) {
    if (result.error === 'not_found') {
      return c.json({ error: 'Orchestrator not set up' }, 404);
    }
    if (result.error === 'handle_taken') {
      return c.json({ error: 'Handle already taken' }, 409);
    }
  }

  if (result.ok) {
    return c.json({ identity: result.identity });
  }

  return c.json({ error: 'Unknown error' }, 500);
});

/**
 * GET /api/me/orchestrator/check-handle?handle=foo
 */
orchestratorRouter.get('/orchestrator/check-handle', async (c) => {
  const handle = c.req.query('handle');
  if (!handle) {
    return c.json({ error: 'handle query param required' }, 400);
  }
  const existing = await db.getOrchestratorIdentityByHandle(c.env.DB, handle);
  const user = c.get('user');
  const available = !existing || existing.userId === user.id;
  return c.json({ available, handle });
});

// ─── Memory Routes ──────────────────────────────────────────────────────

/**
 * GET /api/me/memories
 */
orchestratorRouter.get('/memories', async (c) => {
  const user = c.get('user');
  const { category, query, limit } = c.req.query();

  const memories = await db.listOrchestratorMemories(c.env.DB, user.id, {
    category,
    query,
    limit: limit ? parseInt(limit) : undefined,
  });

  return c.json({ memories });
});

/**
 * POST /api/me/memories
 */
orchestratorRouter.post('/memories', zValidator('json', createMemorySchema), async (c) => {
  const user = c.get('user');
  const body = c.req.valid('json');

  const id = crypto.randomUUID();
  const memory = await db.createOrchestratorMemory(c.env.DB, {
    id,
    userId: user.id,
    category: body.category,
    content: body.content,
  });

  return c.json({ memory }, 201);
});

/**
 * DELETE /api/me/memories/:id
 */
orchestratorRouter.delete('/memories/:id', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  const deleted = await db.deleteOrchestratorMemory(c.env.DB, id, user.id);
  if (!deleted) {
    return c.json({ error: 'Memory not found' }, 404);
  }

  return c.json({ success: true });
});

// ─── Notification Queue Routes (Phase C) ────────────────────────────────

async function listNotifications(c: Context<{ Bindings: Env; Variables: Variables }>) {
  const user = c.get('user');
  const unreadOnly = c.req.query('unreadOnly') === 'true';
  const messageType = c.req.query('messageType') || undefined;
  const limitRaw = c.req.query('limit');
  const limit = limitRaw ? parseInt(limitRaw, 10) : undefined;
  const cursor = c.req.query('cursor') || undefined;

  const result = await db.getUserNotifications(c.env.DB, user.id, {
    unreadOnly,
    messageType,
    limit,
    cursor,
  });
  return c.json(result);
}

async function getNotificationCount(c: Context<{ Bindings: Env; Variables: Variables }>) {
  const user = c.get('user');
  const count = await db.getUserNotificationCount(c.env.DB, user.id);
  return c.json({ count });
}

async function getNotificationThread(c: Context<{ Bindings: Env; Variables: Variables }>) {
  const user = c.get('user');
  const { threadId } = c.req.param();

  const thread = await db.getNotificationThread(c.env.DB, threadId, user.id);
  if (!thread.rootMessage) {
    return c.json({ error: 'Thread not found' }, 404);
  }

  await db.markNotificationThreadRead(c.env.DB, threadId, user.id);

  return c.json({
    rootMessage: thread.rootMessage,
    replies: thread.replies,
    totalCount: 1 + thread.replies.length,
  });
}

async function markNotificationRead(c: Context<{ Bindings: Env; Variables: Variables }>) {
  const user = c.get('user');
  const { messageId } = c.req.param();

  const success = await db.markNotificationRead(c.env.DB, messageId, user.id);
  if (!success) {
    return c.json({ error: 'Message not found or already read' }, 404);
  }
  return c.json({ success: true });
}

async function replyToNotification(c: Context<{ Bindings: Env; Variables: Variables }>) {
  const user = c.get('user');
  const { messageId } = c.req.param();
  const body = await c.req.json<{ content: string }>();

  if (!body.content?.trim()) {
    return c.json({ error: 'content is required' }, 400);
  }

  const original = await db.getMailboxMessage(c.env.DB, messageId);
  if (!original) {
    return c.json({ error: 'Message not found' }, 404);
  }

  const threadRootId = original.replyToId || original.id;
  const rootMessage = original.replyToId
    ? await db.getMailboxMessage(c.env.DB, threadRootId)
    : original;
  if (!rootMessage) {
    return c.json({ error: 'Thread not found' }, 404);
  }

  if (rootMessage.toUserId !== user.id && rootMessage.fromUserId !== user.id) {
    return c.json({ error: 'Message not found' }, 404);
  }

  const isRecipient = rootMessage.toUserId === user.id;
  const reply = await db.enqueueNotification(c.env.DB, {
    fromUserId: user.id,
    toSessionId: isRecipient ? rootMessage.fromSessionId : rootMessage.toSessionId,
    toUserId: isRecipient ? rootMessage.fromUserId : rootMessage.toUserId,
    messageType: rootMessage.messageType,
    content: body.content,
    contextSessionId: rootMessage.contextSessionId,
    contextTaskId: rootMessage.contextTaskId,
    replyToId: threadRootId,
  });

  return c.json({ message: reply }, 201);
}

orchestratorRouter.get('/notifications', listNotifications);
orchestratorRouter.get('/notifications/count', getNotificationCount);
orchestratorRouter.get('/notifications/threads/:threadId', getNotificationThread);
orchestratorRouter.put('/notifications/:messageId/read', markNotificationRead);

orchestratorRouter.put('/notifications/read-non-actionable', async (c) => {
  const user = c.get('user');
  const count = await db.markNonActionableNotificationsRead(c.env.DB, user.id);
  return c.json({ success: true, count });
});

orchestratorRouter.put('/notifications/read-all', async (c) => {
  const user = c.get('user');
  const count = await db.markAllNotificationsRead(c.env.DB, user.id);
  return c.json({ success: true, count });
});

orchestratorRouter.post('/notifications/:messageId/reply', replyToNotification);

// ─── Notification Preferences Routes (Phase C) ─────────────────────────

orchestratorRouter.get('/notification-preferences', async (c) => {
  const user = c.get('user');
  const preferences = await db.getNotificationPreferences(c.env.DB, user.id);
  return c.json({ preferences });
});

orchestratorRouter.put('/notification-preferences', async (c) => {
  const user = c.get('user');
  const body = await c.req.json<{
    messageType: string;
    eventType?: string;
    webEnabled?: boolean;
    slackEnabled?: boolean;
    emailEnabled?: boolean;
  }>();

  if (!body.messageType) {
    return c.json({ error: 'messageType is required' }, 400);
  }

  const pref = await db.upsertNotificationPreference(c.env.DB, user.id, body.messageType, body.eventType, {
    webEnabled: body.webEnabled,
    slackEnabled: body.slackEnabled,
    emailEnabled: body.emailEnabled,
  });

  return c.json({ preference: pref });
});

// ─── Org Directory Routes (Phase C) ────────────────────────────────────

orchestratorRouter.get('/org-agents', async (c) => {
  try {
    const orgSettings = await db.getOrgSettings(c.env.DB);
    const agents = await db.getOrgAgents(c.env.DB, orgSettings.id);
    return c.json({ agents });
  } catch {
    return c.json({ agents: [] });
  }
});

// ─── Identity Link Routes (Phase D) ──────────────────────────────────────

orchestratorRouter.get('/identity-links', async (c) => {
  const user = c.get('user');
  const links = await db.getUserIdentityLinks(c.env.DB, user.id);
  return c.json({ links });
});

orchestratorRouter.post('/identity-links', zValidator('json', createIdentityLinkSchema), async (c) => {
  const user = c.get('user');
  const body = c.req.valid('json');

  const id = crypto.randomUUID();
  try {
    const link = await db.createIdentityLink(c.env.DB, {
      id,
      userId: user.id,
      provider: body.provider,
      externalId: body.externalId,
      externalName: body.externalName,
      teamId: body.teamId,
    });
    return c.json({ link }, 201);
  } catch (err: any) {
    if (err?.message?.includes('UNIQUE constraint failed')) {
      return c.json({ error: 'This external identity is already linked' }, 409);
    }
    throw err;
  }
});

orchestratorRouter.delete('/identity-links/:id', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  const deleted = await db.deleteIdentityLink(c.env.DB, id, user.id);
  if (!deleted) {
    return c.json({ error: 'Identity link not found' }, 404);
  }

  return c.json({ success: true });
});
