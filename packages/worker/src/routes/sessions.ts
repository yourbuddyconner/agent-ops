import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import type { Env, Variables } from '../env.js';
import * as db from '../lib/db.js';
import * as sessionService from '../services/sessions.js';

export const sessionsRouter = new Hono<{ Bindings: Env; Variables: Variables }>();

// Validation schemas
const createSessionSchema = z.object({
  workspace: z.string().min(1).max(100),
  repoUrl: z.string().url().optional(),
  branch: z.string().optional(),
  ref: z.string().optional(),
  title: z.string().max(200).optional(),
  parentSessionId: z.string().uuid().optional(),
  config: z
    .object({
      memory: z.string().optional(),
      timeout: z.number().optional(),
    })
    .optional(),
  sourceType: z.enum(['pr', 'issue', 'branch', 'manual']).optional(),
  sourcePrNumber: z.number().int().positive().optional(),
  sourceIssueNumber: z.number().int().positive().optional(),
  sourceRepoFullName: z.string().optional(),
  initialPrompt: z.string().max(100000).optional(),
  initialModel: z.string().max(255).optional(),
  personaId: z.string().uuid().optional(),
});

const sendMessageSchema = z.object({
  content: z.string().min(1).max(100000),
  attachments: z
    .array(
      z.object({
        type: z.enum(['file', 'url']),
        name: z.string(),
        data: z.string(),
        mimeType: z.string().optional(),
      })
    )
    .optional(),
});

/**
 * GET /api/sessions
 * List user's sessions
 */
sessionsRouter.get('/', async (c) => {
  const user = c.get('user');
  const { limit, cursor, status, ownership } = c.req.query();

  const result = await db.getUserSessions(c.env.DB, user.id, {
    limit: limit ? parseInt(limit) : undefined,
    cursor,
    status,
    ownership: ownership as db.SessionOwnershipFilter | undefined,
  });

  return c.json(result);
});

/**
 * POST /api/sessions
 * Create a new agent session.
 */
sessionsRouter.post('/', zValidator('json', createSessionSchema), async (c) => {
  const user = c.get('user');
  const body = c.req.valid('json');

  const result = await sessionService.createSession(
    c.env,
    { ...body, userId: user.id, userEmail: user.email },
    { url: c.req.url, host: c.req.header('host') || undefined },
  );

  if (!result.ok) {
    return c.json(
      { error: result.message, activeCount: result.activeCount, limit: result.limit },
      429
    );
  }
  return c.json(result, 201);
});

/**
 * GET /api/sessions/available-models
 * Returns the list of available models.
 */
sessionsRouter.get('/available-models', async (c) => {
  const user = c.get('user');
  const orchSession = await db.getOrchestratorSession(c.env.DB, user.id);
  const orchestratorId = orchSession?.id ?? `orchestrator:${user.id}`;

  try {
    const doId = c.env.SESSIONS.idFromName(orchestratorId);
    const sessionDO = c.env.SESSIONS.get(doId);

    const resp = await sessionDO.fetch(new Request('http://do/models'));
    if (resp.ok) {
      const data = await resp.json() as { models: unknown[] };
      if (data.models && data.models.length > 0) {
        return c.json(data);
      }
    }
  } catch {
    // DO may not exist or be unreachable — fall through to D1 cache
  }

  try {
    const models = await db.getUserDiscoveredModels(c.env.DB, user.id);
    if (models && models.length > 0) {
      return c.json({ models });
    }
  } catch {
    // D1 read failed — return empty
  }

  return c.json({ models: [] });
});

/**
 * POST /api/sessions/join/:token
 * Redeem a share link and join as a participant
 */
sessionsRouter.post('/join/:token', async (c) => {
  const user = c.get('user');
  const { token } = c.req.param();

  const result = await sessionService.joinSessionViaShareLink(c.env.DB, token, user.id);
  if (!result) {
    return c.json({ error: 'Invalid, expired, or exhausted share link' }, 400);
  }

  return c.json({ sessionId: result.sessionId, role: result.role });
});

/**
 * GET /api/sessions/:id
 * Get session details
 */
sessionsRouter.get('/:id', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  const result = await sessionService.getSessionWithStatus(c.env, id, user.id);
  return c.json(result);
});

/**
 * GET /api/sessions/:id/git-state
 * Get the git state for a session
 */
sessionsRouter.get('/:id/git-state', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');

  const gitState = await db.getSessionGitState(c.env.DB, id);

  return c.json({ gitState });
});

/**
 * GET /api/sessions/:id/sandbox-token
 * Issue a short-lived JWT for direct iframe access to sandbox tunnel URLs.
 */
sessionsRouter.get('/:id/sandbox-token', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  const result = await sessionService.issueSandboxToken(c.env, id, user.id);

  if ('error' in result) {
    return c.json({ error: result.error }, result.status);
  }
  if ('hibernatedStatus' in result) {
    return c.json({ status: result.hibernatedStatus }, result.status);
  }

  return c.json(result);
});

/**
 * GET /api/sessions/:id/tunnels
 * Get tunnel URLs for a running session.
 */
sessionsRouter.get('/:id/tunnels', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');

  const doId = c.env.SESSIONS.idFromName(id);
  const sessionDO = c.env.SESSIONS.get(doId);

  const statusRes = await sessionDO.fetch(new Request('http://do/status'));
  const statusData = await statusRes.json() as {
    tunnelUrls?: Record<string, string> | null;
    tunnels?: Array<{ name: string; url?: string; path?: string; port?: number; protocol?: string }> | null;
  };

  return c.json({
    gatewayUrl: statusData.tunnelUrls?.gateway ?? null,
    tunnels: statusData.tunnels ?? [],
  });
});

/**
 * DELETE /api/sessions/:id/tunnels/:name
 * Unregister a sandbox tunnel by name (delegated to the runner).
 */
sessionsRouter.delete('/:id/tunnels/:name', async (c) => {
  const user = c.get('user');
  const { id, name } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'collaborator');

  const doId = c.env.SESSIONS.idFromName(id);
  const sessionDO = c.env.SESSIONS.get(doId);

  const resp = await sessionDO.fetch(new Request('http://do/tunnels', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      action: 'delete',
      name,
      actorId: user.id,
      actorName: user.email,
      actorEmail: user.email,
    }),
  }));

  if (!resp.ok) {
    const errText = await resp.text();
    return c.json({ error: errText || 'Failed to delete tunnel' }, resp.status as 400 | 401 | 403 | 404 | 409 | 422 | 500);
  }

  return c.json({ success: true });
});

/**
 * POST /api/sessions/:id/messages
 * Send a message/prompt to the session agent.
 */
sessionsRouter.post('/:id/messages', zValidator('json', sendMessageSchema), async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const body = c.req.valid('json');

  const result = await sessionService.sendSessionMessage(c.env, id, user.id, user.email, body.content);
  return c.json({ success: true, messageId: result.messageId });
});

/**
 * POST /api/sessions/:id/clear-queue
 * Clear the prompt queue for a session.
 */
sessionsRouter.post('/:id/clear-queue', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'collaborator');

  const doId = c.env.SESSIONS.idFromName(id);
  const sessionDO = c.env.SESSIONS.get(doId);

  const res = await sessionDO.fetch(new Request('http://do/clear-queue', { method: 'POST' }));
  const result = await res.json() as { cleared: number };

  return c.json(result);
});

/**
 * GET /api/sessions/:id/messages
 * Get session message history
 */
sessionsRouter.get('/:id/messages', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const { limit, after } = c.req.query();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');

  const messages = await db.getSessionMessages(c.env.DB, id, {
    limit: limit ? parseInt(limit) : undefined,
    after,
  });

  return c.json({ messages });
});

/**
 * GET /api/sessions/:id/ws
 * WebSocket upgrade — proxies to SessionAgentDO.
 */
sessionsRouter.get('/:id/ws', async (c) => {
  const { id } = c.req.param();

  const role = c.req.query('role');

  if (role === 'client') {
    const user = c.get('user');
    await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');
  }

  const doId = c.env.SESSIONS.idFromName(id);
  const sessionDO = c.env.SESSIONS.get(doId);

  return sessionDO.fetch(c.req.raw);
});

/**
 * GET /api/sessions/:id/events
 * Server-Sent Events endpoint for real-time updates
 */
sessionsRouter.get('/:id/events', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');

  const { readable, writable } = new TransformStream();
  const writer = writable.getWriter();
  const encoder = new TextEncoder();

  writer.write(encoder.encode(`event: connected\ndata: {"sessionId":"${id}"}\n\n`));

  const heartbeat = setInterval(async () => {
    try {
      await writer.write(encoder.encode(`: heartbeat\n\n`));
    } catch {
      clearInterval(heartbeat);
    }
  }, 30000);

  c.req.raw.signal.addEventListener('abort', () => {
    clearInterval(heartbeat);
    writer.close();
  });

  return new Response(readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
});

/**
 * POST /api/sessions/:id/hibernate
 * Hibernate a running session.
 */
sessionsRouter.post('/:id/hibernate', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'collaborator');

  const doId = c.env.SESSIONS.idFromName(id);
  const sessionDO = c.env.SESSIONS.get(doId);

  const res = await sessionDO.fetch(new Request('http://do/hibernate', { method: 'POST' }));
  const result = await res.json() as { status: string; message: string };

  return c.json(result);
});

/**
 * POST /api/sessions/:id/wake
 * Wake a hibernated session.
 */
sessionsRouter.post('/:id/wake', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'collaborator');

  const doId = c.env.SESSIONS.idFromName(id);
  const sessionDO = c.env.SESSIONS.get(doId);

  const res = await sessionDO.fetch(new Request('http://do/wake', { method: 'POST' }));
  const result = await res.json() as { status: string; message: string };

  return c.json(result);
});

/**
 * POST /api/sessions/bulk-delete
 * Permanently delete multiple sessions.
 */
const bulkDeleteSchema = z.object({
  sessionIds: z.array(z.string().uuid()).min(1).max(100),
});

sessionsRouter.post('/bulk-delete', zValidator('json', bulkDeleteSchema), async (c) => {
  const user = c.get('user');
  const { sessionIds } = c.req.valid('json');

  const result = await sessionService.bulkDeleteSessions(c.env, user.id, sessionIds);
  return c.json(result);
});

/**
 * GET /api/sessions/:id/children
 * Get child sessions for a parent session (paginated).
 */
sessionsRouter.get('/:id/children', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const { limit, cursor, status, hideTerminated } = c.req.query();

  const result = await sessionService.getEnrichedChildSessions(c.env, id, user.id, {
    limit: limit ? parseInt(limit) : undefined,
    cursor,
    status,
    hideTerminated: hideTerminated === 'true',
  });

  return c.json(result);
});

/**
 * GET /api/sessions/:id/audit-log
 * Get the audit log for a session.
 */
sessionsRouter.get('/:id/audit-log', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const { limit, after, eventType } = c.req.query();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');

  const entries = await db.getSessionAuditLog(c.env.DB, id, {
    limit: limit ? parseInt(limit) : undefined,
    after,
    eventType,
  });
  return c.json({ entries });
});

/**
 * GET /api/sessions/:id/files-changed
 * Get files changed in a session.
 */
sessionsRouter.get('/:id/files-changed', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');

  const files = await db.getSessionFilesChanged(c.env.DB, id);
  return c.json({ files });
});

/**
 * PATCH /api/sessions/:id
 * Update session title.
 */
const updateSessionSchema = z.object({
  title: z.string().max(200),
});

sessionsRouter.patch('/:id', zValidator('json', updateSessionSchema), async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const body = c.req.valid('json');

  await db.assertSessionAccess(c.env.DB, id, user.id, 'owner');

  await db.updateSessionTitle(c.env.DB, id, body.title);
  return c.json({ success: true });
});

/**
 * DELETE /api/sessions/:id
 * Terminate a session.
 */
sessionsRouter.delete('/:id', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  await sessionService.terminateSession(c.env, id, user.id);
  return c.json({ success: true });
});

// ─── Participant Management Endpoints ─────────────────────────────────────

/**
 * GET /api/sessions/:id/participants
 */
sessionsRouter.get('/:id/participants', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  const session = await db.assertSessionAccess(c.env.DB, id, user.id, 'viewer');
  sessionService.assertSessionShareable(session);

  const allParticipants = await sessionService.getSessionParticipantsWithOwner(c.env.DB, id, session.userId);

  return c.json({ participants: allParticipants });
});

const addParticipantSchema = z.object({
  userId: z.string().optional(),
  email: z.string().email().optional(),
  role: z.enum(['collaborator', 'viewer']).default('collaborator'),
}).refine((d) => d.userId || d.email, { message: 'userId or email required' });

/**
 * POST /api/sessions/:id/participants
 */
sessionsRouter.post('/:id/participants', zValidator('json', addParticipantSchema), async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const body = c.req.valid('json');

  await sessionService.addSessionParticipant(c.env.DB, id, user.id, { userId: body.userId, email: body.email }, body.role);
  return c.json({ success: true });
});

/**
 * DELETE /api/sessions/:id/participants/:userId
 */
sessionsRouter.delete('/:id/participants/:userId', async (c) => {
  const user = c.get('user');
  const { id, userId: targetUserId } = c.req.param();

  const session = await db.assertSessionAccess(c.env.DB, id, user.id, 'owner');
  sessionService.assertSessionShareable(session);

  await db.removeSessionParticipant(c.env.DB, id, targetUserId);

  return c.json({ success: true });
});

// ─── Share Link Endpoints ─────────────────────────────────────────────────

const createShareLinkSchema = z.object({
  role: z.enum(['collaborator', 'viewer']).default('collaborator'),
  expiresAt: z.string().datetime().optional(),
  maxUses: z.number().int().positive().optional(),
});

/**
 * POST /api/sessions/:id/share-link
 */
sessionsRouter.post('/:id/share-link', zValidator('json', createShareLinkSchema), async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();
  const body = c.req.valid('json');

  const session = await db.assertSessionAccess(c.env.DB, id, user.id, 'owner');
  sessionService.assertSessionShareable(session);

  const link = await db.createShareLink(c.env.DB, id, body.role, user.id, body.expiresAt, body.maxUses);

  return c.json({ shareLink: link }, 201);
});

/**
 * GET /api/sessions/:id/share-links
 */
sessionsRouter.get('/:id/share-links', async (c) => {
  const user = c.get('user');
  const { id } = c.req.param();

  const session = await db.assertSessionAccess(c.env.DB, id, user.id, 'owner');
  sessionService.assertSessionShareable(session);

  const links = await db.getSessionShareLinks(c.env.DB, id);

  return c.json({ shareLinks: links });
});

/**
 * DELETE /api/sessions/:id/share-link/:linkId
 */
sessionsRouter.delete('/:id/share-link/:linkId', async (c) => {
  const user = c.get('user');
  const { id, linkId } = c.req.param();

  const session = await db.assertSessionAccess(c.env.DB, id, user.id, 'owner');
  sessionService.assertSessionShareable(session);

  await db.deactivateShareLink(c.env.DB, linkId);

  return c.json({ success: true });
});
